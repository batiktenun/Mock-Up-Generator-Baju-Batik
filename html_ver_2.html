<!DOCTYPE html><html lang="id">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Mockup - UI Ringkas (Terintegrasi)</title>
<style>
  body { margin:0; padding:0; background:#ddd; font-family:system-ui; }
  #workArea { width:100vw; height:100vh; background:linear-gradient(#eee,#f7f7f7); position:relative; overflow:hidden; }
  canvas { position:absolute; top:50%; left:50%; transform:translate(-50%,-50%); background:white; border-radius:8px; box-shadow:0 6px 18px rgba(0,0,0,.08); }
  #topTools { position:absolute; top:12px; left:12px; display:flex; gap:10px; align-items:center; }
  .iconBtn { width:44px; height:44px; border-radius:10px; background:#fafafa; display:flex; align-items:center; justify-content:center; cursor:pointer; border:1px solid rgba(0,0,0,0.06); font-size:18px; }
  .iconBtn.active { background:#0b66ff; color:white; }
  .panel { position:absolute; top:70px; left:12px; padding:12px; width:260px; background:white; border-radius:10px; box-shadow:0 6px 20px rgba(0,0,0,0.12); display:none; z-index:30; }
  .panel label{display:block;margin-top:6px;font-size:13px;color:#333}
  .panel input[type=file]{width:100%}
  .panel input[type=range]{width:100%}
  /* Tuning diganti panel popup di bawah */
  #bottomPanel{
    position:absolute;
    bottom:12px;
    left:12px;
    right:12px;
    padding:14px;
    background:rgba(255,255,255,0.98);
    border-radius:14px;
    box-shadow:0 8px 26px rgba(0,0,0,.06);
    z-index:50;
    display:none;
  }
    <div id="smallBtns">
    <div class="mini" id="centerBtn">Center</div>
    <div class="mini" id="downloadBtn">Download</div>
    <div class="mini" id="resetBtn">Reset</div>
  </div>  <!-- panels -->  <div class="panel" id="uploadPanel">
    <label>Baju (PNG transparan)</label>
    <input type="file" id="shirtFile" accept="image/*">
    <label>Motif</label>
    <input type="file" id="patternFile" accept="image/*">
  </div>  <div class="panel" id="transformPanel">
    <label>Pos X</label>
    <input type="range" id="posX" min="-2000" max="2000">
    <label>Pos Y</label>
    <input type="range" id="posY" min="-2000" max="2000">
    <label>Scale</label>
    <input type="range" id="scale" min="0.1" max="5" step="0.01">
    <label>Rotation</label>
    <input type="range" id="rotation" min="-180" max="180">
    <label>Opacity</label>
    <input type="range" id="opacity" min="0" max="1" step="0.01">
  </div>  <div class="panel" id="eraserPanel">
    <label>Brush Size</label>
    <input type="range" id="brushSize" min="4" max="200" value="40">
    <label>Hardness</label>
    <input type="range" id="brushHard" min="0" max="1" step="0.01" value="0.6">
    <div style="margin-top:8px;display:flex;gap:8px">
      <button id="resetErase">Reset Erase</button>
    </div>
  </div>  <div class="panel" id="displacePanel">
    <label><input type="checkbox" id="displaceToggle"> Aktifkan Displacement</label>
    <label>Kekuatan</label>
    <input type="range" id="displaceStrength" min="0" max="120" value="18">
  </div>  <div id="tunePanel">
    <div id="tuneLabel">Tuning: <span id="modeLabel">—</span></div>
    <input type="range" id="tuneSlider" min="0" max="100" value="50">
    <div style="width:120px;text-align:right"><span id="tuneValue">50</span></div>
  </div></div><script>
/* Integrated JS: behavior for panels, single tuning control, canvas pipeline adapted from original file. */
const c = document.getElementById('c'); const ctx = c.getContext('2d');
let shirtImg=null, patternImg=null; let patternState={x:c.width/2,y:c.height/2,scale:1,rot:0,alpha:1,tiled:false};

// erase mask and undo/redo stacks
const eraseMask = document.createElement('canvas'); let eraseMaskCtx = eraseMask.getContext('2d');
const undoStack=[]; const redoStack=[]; const UNDO_LIMIT=30;

// UI refs
const uploadBtn=document.getElementById('uploadBtn'); const transformBtn=document.getElementById('transformBtn'); const eraseBtn=document.getElementById('eraseBtn'); const displaceBtn=document.getElementById('displaceBtn');
const uploadPanel=document.getElementById('uploadPanel'); const transformPanel=document.getElementById('transformPanel'); const eraserPanel=document.getElementById('eraserPanel'); const displacePanel=document.getElementById('displacePanel');
const shirtFile=document.getElementById('shirtFile'); const patternFile=document.getElementById('patternFile');
const posX=document.getElementById('posX'); const posY=document.getElementById('posY'); const scaleEl=document.getElementById('scale'); const rotationEl=document.getElementById('rotation'); const opacityEl=document.getElementById('opacity');
const brushSizeEl=document.getElementById('brushSize'); const brushHardEl=document.getElementById('brushHard'); const resetEraseBtn=document.getElementById('resetErase');
const displaceToggle=document.getElementById('displaceToggle'); const displaceStrength=document.getElementById('displaceStrength');
const centerBtn=document.getElementById('centerBtn'); const downloadBtn=document.getElementById('downloadBtn'); const resetBtn=document.getElementById('resetBtn');
const undoBtn=document.getElementById('undoBtn'); const redoBtn=document.getElementById('redoBtn');
const tuneSlider=document.getElementById('tuneSlider'); const tuneLabel=document.getElementById('modeLabel'); const tuneValue=document.getElementById('tuneValue');

// panel toggle helper
function hideAllPanels(){ uploadPanel.style.display='none'; transformPanel.style.display='none'; eraserPanel.style.display='none'; displacePanel.style.display='none'; [uploadBtn,transformBtn,eraseBtn,displaceBtn].forEach(b=>b.classList.remove('active')); }
uploadBtn.addEventListener('click', ()=>{ const show = uploadPanel.style.display!=='block'; hideAllPanels(); if(show){ uploadPanel.style.display='block'; uploadBtn.classList.add('active'); } });
transformBtn.addEventListener('click', ()=>{ const show = transformPanel.style.display!=='block'; hideAllPanels(); if(show){ transformPanel.style.display='block'; transformBtn.classList.add('active'); } });
eraseBtn.addEventListener('click', ()=>{ const show = eraserPanel.style.display!=='block'; hideAllPanels(); if(show){ eraserPanel.style.display='block'; eraseBtn.classList.add('active'); } });
displaceBtn.addEventListener('click', ()=>{ const show = displacePanel.style.display!=='block'; hideAllPanels(); if(show){ displacePanel.style.display='block'; displaceBtn.classList.add('active'); } });

// file loaders
function loadImageFromFile(file, cb){ const r=new FileReader(); r.onload=e=>{ const img=new Image(); img.onload=()=>cb(img); img.src=e.target.result; }; r.readAsDataURL(file); }
shirtFile.addEventListener('change', e=>{ const f=e.target.files[0]; if(!f) return; loadImageFromFile(f,img=>{ shirtImg=img; fitCanvasToShirt(); generateMaskFromShirt(); computeLuminanceMap(); ensureEraseMaskSize(c.width,c.height); draw(); }); });
patternFile.addEventListener('change', e=>{ const f=e.target.files[0]; if(!f) return; loadImageFromFile(f,img=>{ patternImg=img; patternState={x:c.width/2,y:c.height/2,scale:1,rot:0,alpha:1,tiled:false}; syncUI(); ensureEraseMaskSize(c.width,c.height); draw(); }); });

// helpers: ensure erase mask size
function ensureEraseMaskSize(w,h){ if(eraseMask.width!==w || eraseMask.height!==h){ eraseMask.width=w; eraseMask.height=h; eraseMaskCtx=eraseMask.getContext('2d'); eraseMaskCtx.clearRect(0,0,w,h); eraseMaskCtx.fillStyle='white'; eraseMaskCtx.fillRect(0,0,w,h); undoStack.length=0; redoStack.length=0; undoBtn.classList.remove('disabled'); } }

function fitCanvasToShirt(){ if(!shirtImg) return; const maxW=1400,maxH=1700; let w=shirtImg.naturalWidth||shirtImg.width, h=shirtImg.naturalHeight||shirtImg.height; const ratio=Math.min(maxW/w,maxH/h,1); c.width=Math.round(w*ratio); c.height=Math.round(h*ratio); // reposition canvas center via CSS transform keeps center
  ensureEraseMaskSize(c.width,c.height);
  if(!patternImg) patternState.x=c.width/2, patternState.y=c.height/2;
}

// mask from shirt alpha (for clipping)
let maskCanvas=null; function generateMaskFromShirt(){ if(!shirtImg){ maskCanvas=null; return; } const tmp=document.createElement('canvas'); tmp.width=c.width; tmp.height=c.height; const tctx=tmp.getContext('2d'); tctx.clearRect(0,0,tmp.width,tmp.height); tctx.drawImage(shirtImg,0,0,tmp.width,tmp.height); const id=tctx.getImageData(0,0,tmp.width,tmp.height).data; const mask=document.createElement('canvas'); mask.width=tmp.width; mask.height=tmp.height; const mctx=mask.getContext('2d'); const mImg=mctx.createImageData(tmp.width,tmp.height); const mData=mImg.data; const TH=10; for(let i=0;i<id.length;i+=4){ const a=id[i+3]; if(a>TH){ mData[i]=255; mData[i+1]=255; mData[i+2]=255; mData[i+3]=255; } else { mData[i]=0; mData[i+1]=0; mData[i+2]=0; mData[i+3]=0; } } mctx.putImageData(mImg,0,0); maskCanvas=mask; }

// luminance map for displacement
let lumMap=null; function computeLuminanceMap(){ if(!shirtImg){ lumMap=null; return; } const tmp=document.createElement('canvas'); tmp.width=c.width; tmp.height=c.height; const tctx=tmp.getContext('2d'); tctx.drawImage(shirtImg,0,0,tmp.width,tmp.height); const id=tctx.getImageData(0,0,tmp.width,tmp.height).data; lumMap=new Float32Array(tmp.width*tmp.height); for(let i=0,j=0;i<id.length;i+=4,j++){ lumMap[j]=(0.2126*id[i]+0.7152*id[i+1]+0.0722*id[i+2])/255; } lumMap=boxBlurFloat(lumMap,tmp.width,tmp.height,2); }
function boxBlurFloat(arr,w,h,radius){ if(radius<1) return arr; const tmp=new Float32Array(arr.length); for(let y=0;y<h;y++) for(let x=0;x<w;x++){ let sum=0,cnt=0; for(let k=-radius;k<=radius;k++){ const xx=x+k; if(xx>=0&&xx<w){ sum+=arr[y*w+xx]; cnt++; } } tmp[y*w+x]=sum/cnt; } const out=new Float32Array(arr.length); for(let x=0;x<w;x++) for(let y=0;y<h;y++){ let sum=0,cnt=0; for(let k=-radius;k<=radius;k++){ const yy=y+k; if(yy>=0&&yy<h){ sum+=tmp[yy*w+x]; cnt++; } } out[y*w+x]=sum/cnt; } return out; }

// draw pipeline
function draw(){ ctx.clearRect(0,0,c.width,c.height); if(shirtImg) ctx.drawImage(shirtImg,0,0,c.width,c.height); else drawCheckerBackground(ctx,c.width,c.height);
  if(!patternImg){ updatePreviews(); return; }
  const pw=c.width, ph=c.height; const patternCanvas=document.createElement('canvas'); patternCanvas.width=pw; patternCanvas.height=ph; const pctx=patternCanvas.getContext('2d'); pctx.save(); pctx.translate(patternState.x,patternState.y); pctx.rotate(patternState.rot*Math.PI/180); pctx.scale(patternState.scale,patternState.scale);
  if(patternState.tiled){ const patt=pctx.createPattern(patternImg,'repeat'); pctx.fillStyle=patt; pctx.fillRect(-pw*2,-ph*2,pw*4,ph*4); }
  else { const w=patternImg.naturalWidth||patternImg.width; const h=patternImg.naturalHeight||patternImg.height; const defaultScale=Math.min((pw*0.6)/w,(ph*0.6)/h); const drawW=w*defaultScale; const drawH=h*defaultScale; pctx.drawImage(patternImg,-drawW/2,-drawH/2,drawW,drawH); }
  pctx.restore();
  // apply eraseMask and shirt mask; displacement if active
  if(!displaceToggle.checked || !lumMap){ const temp=document.createElement('canvas'); temp.width=pw; temp.height=ph; const tctx=temp.getContext('2d'); tctx.drawImage(pctx.canvas,0,0);
    if(eraseMask.width && eraseMask.height){ tctx.globalCompositeOperation='destination-in'; tctx.drawImage(eraseMask,0,0); tctx.globalCompositeOperation='source-over'; }
    if(maskCanvas){ tctx.globalCompositeOperation='destination-in'; tctx.drawImage(maskCanvas,0,0); tctx.globalCompositeOperation='source-over'; }
    ctx.globalAlpha=patternState.alpha; ctx.globalCompositeOperation='multiply'; ctx.drawImage(temp,0,0); ctx.globalCompositeOperation='source-over'; ctx.globalAlpha=1; updatePreviews(); return; }

  // displacement path (simplified)
  const pData = pctx.getImageData(0,0,pw,ph).data; const displaced=document.createElement('canvas'); displaced.width=pw; displaced.height=ph; const dctx=displaced.getContext('2d'); const out=dctx.createImageData(pw,ph); const outData=out.data; const strength=Number(displaceStrength.value);
  const gx=new Float32Array(pw*ph), gy=new Float32Array(pw*ph);
  for(let y=0;y<ph;y++) for(let x=0;x<pw;x++){ const i=y*pw+x; const left=x>0?lumMap[i-1]:lumMap[i]; const right=x<pw-1?lumMap[i+1]:lumMap[i]; const top=y>0?lumMap[i-pw]:lumMap[i]; const bottom=y<ph-1?lumMap[i+pw]:lumMap[i]; gx[i]=right-left; gy[i]=bottom-top; }
  for(let y=0;y<ph;y++) for(let x=0;x<pw;x++){ const i=y*pw+x; const dx=-gx[i]*(strength/50); const dy=-gy[i]*(strength/50); let sx=Math.round(x+dx), sy=Math.round(y+dy); if(sx<0) sx=0; if(sx>=pw) sx=pw-1; if(sy<0) sy=0; if(sy>=ph) sy=ph-1; const si=(sy*pw+sx)*4, oi=i*4; outData[oi]=pData[si]; outData[oi+1]=pData[si+1]; outData[oi+2]=pData[si+2]; outData[oi+3]=pData[si+3]; }
  dctx.putImageData(out,0,0);
  // apply masks
  const temp2=document.createElement('canvas'); temp2.width=pw; temp2.height=ph; const tt=temp2.getContext('2d'); tt.drawImage(displaced,0,0);
  if(eraseMask.width && eraseMask.height){ tt.globalCompositeOperation='destination-in'; tt.drawImage(eraseMask,0,0); tt.globalCompositeOperation='source-over'; }
  if(maskCanvas){ tt.globalCompositeOperation='destination-in'; tt.drawImage(maskCanvas,0,0); tt.globalCompositeOperation='source-over'; }
  ctx.globalAlpha=patternState.alpha; ctx.globalCompositeOperation='multiply'; ctx.drawImage(temp2,0,0); ctx.globalCompositeOperation='source-over'; ctx.globalAlpha=1; updatePreviews(); }

function updatePreviews(){ /* no small previews in simplified UI; placeholder if needed */ }
function drawCheckerBackground(context,w,h){ const size=16; for(let y=0;y<h;y+=size) for(let x=0;x<w;x+=size){ const even=((x/size)+(y/size))%2===0; context.fillStyle=even?'#f8f8f8':'#efefef'; context.fillRect(x,y,size,size); } }

// Sync UI
function syncUI(){ posX.value=Math.round(patternState.x); posY.value=Math.round(patternState.y); scaleEl.value=patternState.scale; rotationEl.value=patternState.rot; opacityEl.value=patternState.alpha; }

// Undo/Redo handling for erase mask
function pushUndo(){ try{ const data=eraseMaskCtx.getImageData(0,0,eraseMask.width,eraseMask.height); undoStack.push(data); if(undoStack.length>UNDO_LIMIT) undoStack.shift(); // clear redo when new action
  redoStack.length=0; updateUndoUI(); }catch(e){} }
function doUndo(){ if(undoStack.length===0) return; const img=undoStack.pop(); redoStack.push(eraseMaskCtx.getImageData(0,0,eraseMask.width,eraseMask.height)); eraseMaskCtx.putImageData(img,0,0); draw(); updateUndoUI(); }
function doRedo(){ if(redoStack.length===0) return; const img=redoStack.pop(); undoStack.push(eraseMaskCtx.getImageData(0,0,eraseMask.width,eraseMask.height)); eraseMaskCtx.putImageData(img,0,0); draw(); updateUndoUI(); }
function updateUndoUI(){ undoBtn.classList.toggle('disabled', undoStack.length===0); redoBtn.classList.toggle('disabled', redoStack.length===0); }
undoBtn.addEventListener('click', doUndo); redoBtn.addEventListener('click', doRedo);
resetEraseBtn.addEventListener('click', ()=>{ pushUndo(); eraseMaskCtx.clearRect(0,0,eraseMask.width,eraseMask.height); eraseMaskCtx.fillStyle='white'; eraseMaskCtx.fillRect(0,0,eraseMask.width,eraseMask.height); draw(); });

// Pointer / brush / dragging logic (multi-touch safe)
const activePointers = new Set(); let eraserMode=true; let isErasing=false; let dragging=false; let dragOffset={x:0,y:0}; let lastPointerId=null;

function doBrushStroke(clientX,clientY){ if(!eraseMaskCtx) return; if(activePointers.size>1) return; const rect=c.getBoundingClientRect(); const x=clientX-rect.left, y=clientY-rect.top; const size=Number(brushSizeEl.value); const hardness=Number(brushHardEl.value);
  const b=document.createElement('canvas'); const bs=Math.max(8,Math.ceil(size)); b.width=bs; b.height=bs; const bctx=b.getContext('2d'); const g=bctx.createRadialGradient(bs/2,bs/2,0,bs/2,bs/2,bs/2); g.addColorStop(0,'rgba(0,0,0,1)'); const stop=Math.max(0,Math.min(1,hardness)); g.addColorStop(stop,'rgba(0,0,0,1)'); g.addColorStop(1,'rgba(0,0,0,0)'); bctx.clearRect(0,0,bs,bs); bctx.fillStyle=g; bctx.fillRect(0,0,bs,bs);
  eraseMaskCtx.save(); eraseMaskCtx.globalCompositeOperation='destination-out'; eraseMaskCtx.drawImage(b, x-bs/2, y-bs/2, bs, bs); eraseMaskCtx.globalCompositeOperation='source-over'; eraseMaskCtx.restore(); draw(); }

c.addEventListener('pointerdown', e=>{ activePointers.add(e.pointerId); if(activePointers.size>1){ isErasing=false; dragging=false; lastPointerId=null; return; }
  const rect=c.getBoundingClientRect(); const x=e.clientX-rect.left, y=e.clientY-rect.top;
  // hit test for pattern dragging if not in eraserMode
  if(!eraserMode && patternImg){ const w=(patternImg.naturalWidth||patternImg.width)*Math.min((c.width*0.6)/(patternImg.naturalWidth||patternImg.width),(c.height*0.6)/(patternImg.naturalHeight||patternImg.height))*patternState.scale; const h=(patternImg.naturalHeight||patternImg.height)*Math.min((c.width*0.6)/(patternImg.naturalWidth||patternImg.width),(c.height*0.6)/(patternImg.naturalHeight||patternImg.height))*patternState.scale; const dx=x-patternState.x, dy=y-patternState.y; const theta=-patternState.rot*Math.PI/180; const rx=dx*Math.cos(theta)-dy*Math.sin(theta), ry=dx*Math.sin(theta)+dy*Math.cos(theta); if(Math.abs(rx)<=w/2+20 && Math.abs(ry)<=h/2+20){ dragging=true; dragOffset.x=dx; dragOffset.y=dy; try{ c.setPointerCapture(e.pointerId);}catch(_){} lastPointerId=e.pointerId; return; } }
  ensureEraseMaskSize(c.width,c.height); pushUndo(); isErasing=true; lastPointerId=e.pointerId; try{ c.setPointerCapture(e.pointerId); }catch(_){} doBrushStroke(e.clientX,e.clientY);
});

c.addEventListener('pointermove', e=>{ if(!activePointers.has(e.pointerId)) activePointers.add(e.pointerId); if(activePointers.size>1) return; if(dragging && !eraserMode){ const rect=c.getBoundingClientRect(); const x=e.clientX-rect.left, y=e.clientY-rect.top; patternState.x = x - dragOffset.x; patternState.y = y - dragOffset.y; syncUI(); draw(); return; } if(!isErasing || lastPointerId!==e.pointerId) return; doBrushStroke(e.clientX,e.clientY); });

c.addEventListener('pointerup', e=>{ activePointers.delete(e.pointerId); if(lastPointerId===e.pointerId){ isErasing=false; dragging=false; try{ c.releasePointerCapture(e.pointerId);}catch(_){} lastPointerId=null; } });
c.addEventListener('pointercancel', e=>{ activePointers.delete(e.pointerId); isErasing=false; dragging=false; lastPointerId=null; });

// sliders
[posX,posY,scaleEl,rotationEl,opacityEl,displaceStrength].forEach(el=>{ el.addEventListener('input', ()=>{ patternState.x=Number(posX.value); patternState.y=Number(posY.value); patternState.scale=Number(scaleEl.value); patternState.rot=Number(rotationEl.value); patternState.alpha=Number(opacityEl.value); draw(); }); });

// toggle eraserMode when clicking eraseBtn: it opens panel but also set mode
eraseBtn.addEventListener('dblclick', ()=>{ eraserMode=!eraserMode; eraseBtn.classList.toggle('active', eraserMode); });

// center/tile/reset/download
centerBtn.addEventListener('click', ()=>{ patternState.x=c.width/2; patternState.y=c.height/2; syncUI(); draw(); });
resetBtn.addEventListener('click', ()=>{ shirtImg=null; patternImg=null; maskCanvas=null; lumMap=null; patternState={x:c.width/2,y:c.height/2,scale:1,rot:0,alpha:1,tiled:false}; eraseMaskCtx.clearRect(0,0,eraseMask.width,eraseMask.height); eraseMaskCtx.fillStyle='white'; eraseMaskCtx.fillRect(0,0,eraseMask.width,eraseMask.height); undoStack.length=0; redoStack.length=0; syncUI(); draw(); });

downloadBtn.addEventListener('click', ()=>{ if(!shirtImg && !patternImg) return; const scaleFactor=2; const tmp=document.createElement('canvas'); tmp.width=c.width*scaleFactor; tmp.height=c.height*scaleFactor; const tctx=tmp.getContext('2d'); if(shirtImg) tctx.drawImage(shirtImg,0,0,tmp.width,tmp.height); else drawCheckerBackground(tctx,tmp.width,tmp.height);
  // build pattern high-res
  const pCanvas=document.createElement('canvas'); pCanvas.width=tmp.width; pCanvas.height=tmp.height; const pctx=pCanvas.getContext('2d'); pctx.save(); pctx.translate(patternState.x*scaleFactor, patternState.y*scaleFactor); pctx.rotate(patternState.rot*Math.PI/180); pctx.scale(patternState.scale,patternState.scale);
  if(patternState.tiled){ const patt=pctx.createPattern(patternImg,'repeat'); pctx.fillStyle=patt; pctx.fillRect(-pCanvas.width,-pCanvas.height,pCanvas.width*2,pCanvas.height*2); }
  else { const w=patternImg.naturalWidth||patternImg.width; const h=patternImg.naturalHeight||patternImg.height; const defaultScale=Math.min((pCanvas.width*0.6)/w,(pCanvas.height*0.6)/h); const drawW=w*defaultScale; const drawH=h*defaultScale; pctx.drawImage(patternImg,-drawW/2,-drawH/2,drawW,drawH); }
  pctx.restore();
  // apply erase mask and maskCanvas scaled
  const eScaled=document.createElement('canvas'); eScaled.width=tmp.width; eScaled.height=tmp.height; const ectx=eScaled.getContext('2d'); ectx.drawImage(eraseMask,0,0,tmp.width,tmp.height);
  const temp=document.createElement('canvas'); temp.width=tmp.width; temp.height=tmp.height; const tt=temp.getContext('2d'); tt.drawImage(pCanvas,0,0); tt.globalCompositeOperation='destination-in'; tt.drawImage(eScaled,0,0); tt.globalCompositeOperation='source-over'; if(maskCanvas){ const mScaled=document.createElement('canvas'); mScaled.width=tmp.width; mScaled.height=tmp.height; const mctx=mScaled.getContext('2d'); mctx.drawImage(maskCanvas,0,0,tmp.width,tmp.height); tt.globalCompositeOperation='destination-in'; tt.drawImage(mScaled,0,0); tt.globalCompositeOperation='source-over'; }
  tctx.globalAlpha=patternState.alpha; tctx.globalCompositeOperation='multiply'; tctx.drawImage(temp,0,0); tctx.globalCompositeOperation='source-over'; tctx.globalAlpha=1;
  const link=document.createElement('a'); link.download='mockup.png'; link.href=tmp.toDataURL('image/png'); link.click();
});

// small UI binding
function syncUI(){ posX.value=Math.round(patternState.x); posY.value=Math.round(patternState.y); scaleEl.value=patternState.scale; rotationEl.value=patternState.rot; opacityEl.value=patternState.alpha; }

// tuning slider single control behavior: maps to currently active panel/function
function updateTuneMode(){ if(uploadPanel.style.display==='block'){ tuneLabel.textContent='Upload'; tuneSlider.min=0; tuneSlider.max=1; tuneSlider.value=1; }
  else if(transformPanel.style.display==='block'){ tuneLabel.textContent='Transform: Scale'; tuneSlider.min=0.1; tuneSlider.max=5; tuneSlider.value=scaleEl.value; }
  else if(eraserPanel.style.display==='block'){ tuneLabel.textContent='Eraser Size'; tuneSlider.min=4; tuneSlider.max=200; tuneSlider.value=brushSizeEl.value; }
  else if(displacePanel.style.display==='block'){ tuneLabel.textContent='Displace Strength'; tuneSlider.min=0; tuneSlider.max=120; tuneSlider.value=displaceStrength.value; }
  else { tuneLabel.textContent='—'; tuneSlider.min=0; tuneSlider.max=100; tuneSlider.value=50; }
  tuneValue.textContent = tuneSlider.value;
}

// sync tune to actual controls
tuneSlider.addEventListener('input', ()=>{ tuneValue.textContent = tuneSlider.value; if(transformPanel.style.display==='block'){ scaleEl.value = tuneSlider.value; scaleEl.dispatchEvent(new Event('input')); } else if(eraserPanel.style.display==='block'){ brushSizeEl.value = tuneSlider.value; } else if(displacePanel.style.display==='block'){ displaceStrength.value = tuneSlider.value; displaceStrength.dispatchEvent(new Event('input')); } });

// whenever panels open/close update mode
[uploadBtn,transformBtn,eraseBtn,displaceBtn].forEach(b=>b.addEventListener('click', ()=>{ setTimeout(updateTuneMode,120); }));

// update whenever underlying sliders change
[scaleEl,brushSizeEl,displaceStrength].forEach(el=>el.addEventListener('input', ()=>{ updateTuneMode(); }));

// pointer to toggle eraserMode: single click on top erase icon toggles active but we also use dblclick to switch painting/eraser behavior
eraseBtn.addEventListener('click', ()=>{ eraserMode = true; eraseBtn.classList.add('active'); transformBtn.classList.remove('active'); });
transformBtn.addEventListener('click', ()=>{ eraserMode = false; transformBtn.classList.add('active'); eraseBtn.classList.remove('active'); });

// initial
function init(){ ensureEraseMaskSize(c.width,c.height); syncUI(); draw(); updateTuneMode(); }
init();

</script></body>
</html>