<!doctype html>
<html lang="id">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Mockup Ringkas â€” Baju + Motif</title>
<style>
  :root{--accent:#0b66ff}
  html,body{height:100%;margin:0;font-family:system-ui,-apple-system,Segoe UI,Roboto;background:#e9ecef}
  #workArea{width:100vw;height:100vh;position:relative;overflow:hidden;background:linear-gradient(#f3f5f7,#efeff1)}
  canvas{position:absolute;top:50%;left:50%;transform:translate(-50%,-50%);background:white;border-radius:8px;box-shadow:0 10px 30px rgba(0,0,0,.08);max-width:none}
  #topTools{position:absolute;top:12px;left:12px;display:flex;gap:10px;align-items:center;z-index:50}
  .iconBtn{width:44px;height:44px;border-radius:10px;background:#fafafa;display:flex;align-items:center;justify-content:center;cursor:pointer;border:1px solid rgba(0,0,0,.06);font-size:18px}
  .iconBtn.active{background:var(--accent);color:#fff}
  .panel{position:absolute;top:70px;left:12px;padding:12px;width:300px;background:#fff;border-radius:10px;box-shadow:0 8px 26px rgba(0,0,0,.12);display:none;z-index:45}
  .panel label{display:block;margin-top:8px;font-size:13px;color:#333}
  .panel input[type=range]{width:100%}
  #tunePanel{position:absolute;bottom:12px;left:12px;right:12px;padding:10px;background:rgba(255,255,255,0.98);border-radius:12px;display:flex;gap:12px;align-items:center;z-index:50;box-shadow:0 8px 26px rgba(0,0,0,.06)}
  #tuneLabel{min-width:110px;color:#333}
  #smallBtns{position:absolute;top:12px;right:12px;display:flex;gap:8px;z-index:50}
  .mini{padding:8px 10px;border-radius:8px;background:#fff;border:1px solid rgba(0,0,0,.06);cursor:pointer;font-size:13px}
  @media (max-width:720px){ .panel{width:220px} canvas{max-width:92vw;height:auto} }
</style>
</head>
<body>
<div id="workArea">
  <canvas id="c" width="900" height="1100" aria-label="mockup canvas"></canvas>

  <div id="topTools">
    <div class="iconBtn" id="undoBtn">âŸ²</div>
    <div class="iconBtn" id="redoBtn">âŸ³</div>

    <div class="iconBtn" id="uploadBtn">ðŸ“¤</div>
    <div class="iconBtn" id="transformBtn">ðŸ”§</div>
    <div class="iconBtn" id="eraseBtn">ðŸ©¹</div>
    <div class="iconBtn" id="displaceBtn">â‰ˆ</div>
  </div>

  <div id="smallBtns">
    <div class="mini" id="centerBtn">Center</div>
    <div class="mini" id="downloadBtn">Download</div>
    <div class="mini" id="resetBtn">Reset</div>
  </div>

  <!-- Upload Panel -->
  <div class="panel" id="uploadPanel">
    <label>Baju (PNG transparan)</label>
    <input type="file" id="shirtFile" accept="image/*">
    <label>Motif</label>
    <input type="file" id="patternFile" accept="image/*">
  </div>

  <!-- Transform Panel -->
  <div class="panel" id="transformPanel">
    <label>Pos X</label>
    <input type="range" id="posX" min="-2000" max="2000">
    <label>Pos Y</label>
    <input type="range" id="posY" min="-2000" max="2000">
    <label>Scale</label>
    <input type="range" id="scale" min="0.1" max="5" step="0.01" value="1">
    <label>Rotation</label>
    <input type="range" id="rotation" min="-180" max="180" value="0">
    <label>Opacity</label>
    <input type="range" id="opacity" min="0" max="1" step="0.01" value="1">
  </div>

  <!-- Eraser Panel -->
  <div class="panel" id="eraserPanel">
    <label>Brush Size</label>
    <input type="range" id="brushSize" min="4" max="200" value="40">
    <label>Hardness</label>
    <input type="range" id="brushHard" min="0" max="1" step="0.01" value="0.6">
    <div style="margin-top:10px;display:flex;gap:8px">
      <button id="resetErase">Reset Erase</button>
    </div>
  </div>

  <!-- Displace Panel -->
  <div class="panel" id="displacePanel">
    <label><input type="checkbox" id="displaceToggle"> Aktifkan Displacement</label>
    <label>Kekuatan</label>
    <input type="range" id="displaceStrength" min="0" max="120" value="18">
  </div>

  <!-- Universal Tuning -->
  <div id="tunePanel">
    <div id="tuneLabel">Tuning: <span id="modeLabel">â€”</span></div>
    <input type="range" id="tuneSlider" min="0" max="100" value="50" style="flex:1">
    <div style="width:70px;text-align:right"><span id="tuneValue">50</span></div>
  </div>
</div>

<script>
/* Final integrated JS */
/* Elements & canvas */
const c = document.getElementById('c'), ctx = c.getContext('2d');
const uploadBtn = document.getElementById('uploadBtn'), transformBtn = document.getElementById('transformBtn'),
      eraseBtn = document.getElementById('eraseBtn'), displaceBtn = document.getElementById('displaceBtn');
const uploadPanel = document.getElementById('uploadPanel'), transformPanel = document.getElementById('transformPanel'),
      eraserPanel = document.getElementById('eraserPanel'), displacePanel = document.getElementById('displacePanel');
const shirtFile = document.getElementById('shirtFile'), patternFile = document.getElementById('patternFile');
const posX = document.getElementById('posX'), posY = document.getElementById('posY'), scaleEl = document.getElementById('scale'),
      rotationEl = document.getElementById('rotation'), opacityEl = document.getElementById('opacity');
const brushSizeEl = document.getElementById('brushSize'), brushHardEl = document.getElementById('brushHard'), resetEraseBtn = document.getElementById('resetErase');
const displaceToggle = document.getElementById('displaceToggle'), displaceStrength = document.getElementById('displaceStrength');
const centerBtn = document.getElementById('centerBtn'), downloadBtn = document.getElementById('downloadBtn'), resetBtn = document.getElementById('resetBtn');
const undoBtn = document.getElementById('undoBtn'), redoBtn = document.getElementById('redoBtn');
const tuneSlider = document.getElementById('tuneSlider'), tuneLabel = document.getElementById('modeLabel'), tuneValue = document.getElementById('tuneValue');

let shirtImg = null, patternImg = null;
let patternState = { x: c.width/2, y: c.height/2, scale:1, rot:0, alpha:1, tiled:false };

/* erase mask + undo/redo */
const eraseMask = document.createElement('canvas'); let eraseMaskCtx = eraseMask.getContext('2d');
const undoStack = [], redoStack = [], UNDO_LIMIT = 30;

/* mask for shirt alpha (clipping) and lumMap for displacement */
let maskCanvas = null, lumMap = null;

/* Panel toggle helper */
function hideAllPanels(){
  uploadPanel.style.display = 'none';
  transformPanel.style.display = 'none';
  eraserPanel.style.display = 'none';
  displacePanel.style.display = 'none';
  [uploadBtn, transformBtn, eraseBtn, displaceBtn].forEach(b => b.classList.remove('active'));
}
uploadBtn.addEventListener('click', ()=>{ const show = uploadPanel.style.display !== 'block'; hideAllPanels(); if(show){ uploadPanel.style.display = 'block'; uploadBtn.classList.add('active'); } updateTuneMode(); });
transformBtn.addEventListener('click', ()=>{ const show = transformPanel.style.display !== 'block'; hideAllPanels(); if(show){ transformPanel.style.display = 'block'; transformBtn.classList.add('active'); } updateTuneMode(); });
eraseBtn.addEventListener('click', ()=>{ const show = eraserPanel.style.display !== 'block'; hideAllPanels(); if(show){ eraserPanel.style.display = 'block'; eraseBtn.classList.add('active'); } updateTuneMode(); });
displaceBtn.addEventListener('click', ()=>{ const show = displacePanel.style.display !== 'block'; hideAllPanels(); if(show){ displacePanel.style.display = 'block'; displaceBtn.classList.add('active'); } updateTuneMode(); });

/* File loader */
function loadImageFromFile(file, cb){
  const r = new FileReader();
  r.onload = e => { const img = new Image(); img.onload = ()=>cb(img); img.src = e.target.result; };
  r.readAsDataURL(file);
}

/* Ensure erase mask size */
function ensureEraseMaskSize(w,h){
  if(eraseMask.width !== w || eraseMask.height !== h){
    eraseMask.width = w; eraseMask.height = h;
    eraseMaskCtx = eraseMask.getContext('2d');
    eraseMaskCtx.clearRect(0,0,w,h);
    eraseMaskCtx.fillStyle = 'white'; eraseMaskCtx.fillRect(0,0,w,h);
    undoStack.length = 0; redoStack.length = 0; updateUndoUI();
  }
}

/* Fit canvas to shirt and CRITICAL: update style dims so canvas remains visible */
function fitCanvasToShirt(){
  if(!shirtImg) return;
  const maxW = 1400, maxH = 1700;
  let w = shirtImg.naturalWidth || shirtImg.width;
  let h = shirtImg.naturalHeight || shirtImg.height;
  const ratio = Math.min(maxW / w, maxH / h, 1);
  c.width = Math.round(w * ratio);
  c.height = Math.round(h * ratio);

  // CRITICAL FIX: make CSS reflect new pixel size so canvas remains visible
  c.style.width = c.width + "px";
  c.style.height = c.height + "px";
  // re-apply transform to remain centered
  c.style.transform = "translate(-50%,-50%)";

  ensureEraseMaskSize(c.width, c.height);
  if(!patternImg){ patternState.x = c.width/2; patternState.y = c.height/2; }
}

/* Generate mask from shirt alpha (clipping) */
function generateMaskFromShirt(){
  if(!shirtImg){ maskCanvas = null; return; }
  const tmp = document.createElement('canvas'); tmp.width = c.width; tmp.height = c.height;
  const tctx = tmp.getContext('2d'); tctx.clearRect(0,0,tmp.width,tmp.height);
  tctx.drawImage(shirtImg,0,0,tmp.width,tmp.height);
  const id = tctx.getImageData(0,0,tmp.width,tmp.height).data;
  const mask = document.createElement('canvas'); mask.width = tmp.width; mask.height = tmp.height;
  const mctx = mask.getContext('2d'); const mImg = mctx.createImageData(tmp.width,tmp.height);
  const mData = mImg.data; const TH = 10;
  for(let i=0;i<id.length;i+=4){
    const a = id[i+3];
    if(a>TH){ mData[i]=255; mData[i+1]=255; mData[i+2]=255; mData[i+3]=255; }
    else { mData[i]=0; mData[i+1]=0; mData[i+2]=0; mData[i+3]=0; }
  }
  mctx.putImageData(mImg,0,0);
  maskCanvas = mask;
}

/* Luminance map for displacement */
function computeLuminanceMap(){
  if(!shirtImg){ lumMap = null; return; }
  const tmp = document.createElement('canvas'); tmp.width = c.width; tmp.height = c.height;
  const tctx = tmp.getContext('2d'); tctx.drawImage(shirtImg,0,0,tmp.width,tmp.height);
  const id = tctx.getImageData(0,0,tmp.width,tmp.height).data;
  lumMap = new Float32Array(tmp.width*tmp.height);
  for(let i=0,j=0;i<id.length;i+=4,j++){ lumMap[j] = (0.2126*id[i] + 0.7152*id[i+1] + 0.0722*id[i+2]) / 255; }
  lumMap = boxBlurFloat(lumMap,tmp.width,tmp.height,2);
}
function boxBlurFloat(arr,w,h,radius){ if(radius<1) return arr; const tmp = new Float32Array(arr.length); for(let y=0;y<h;y++) for(let x=0;x<w;x++){ let sum=0,cnt=0; for(let k=-radius;k<=radius;k++){ const xx=x+k; if(xx>=0 && xx<w){ sum+=arr[y*w+xx]; cnt++; } } tmp[y*w+x]=sum/cnt; } const out=new Float32Array(arr.length); for(let x=0;x<w;x++) for(let y=0;y<h;y++){ let sum=0,cnt=0; for(let k=-radius;k<=radius;k++){ const yy=y+k; if(yy>=0 && yy<h){ sum+=tmp[yy*w+x]; cnt++; } } out[y*w+x]=sum/cnt; } return out; }

/* Drawing pipeline */
function draw(){
  ctx.clearRect(0,0,c.width,c.height);
  if(shirtImg) ctx.drawImage(shirtImg,0,0,c.width,c.height); else drawCheckerBackground(ctx,c.width,c.height);

  if(!patternImg) return;

  const pw = c.width, ph = c.height;
  const patternCanvas = document.createElement('canvas'); patternCanvas.width = pw; patternCanvas.height = ph;
  const pctx = patternCanvas.getContext('2d'); pctx.clearRect(0,0,pw,ph);
  pctx.save();
  pctx.translate(patternState.x, patternState.y);
  pctx.rotate(patternState.rot * Math.PI/180);
  pctx.scale(patternState.scale, patternState.scale);

  if(patternState.tiled){
    const patt = pctx.createPattern(patternImg, 'repeat');
    pctx.fillStyle = patt;
    pctx.fillRect(-pw*2, -ph*2, pw*4, ph*4);
  } else {
    const w = patternImg.naturalWidth || patternImg.width;
    const h = patternImg.naturalHeight || patternImg.height;
    const defaultScale = Math.min((pw*0.6)/w, (ph*0.6)/h);
    const drawW = w * defaultScale;
    const drawH = h * defaultScale;
    pctx.drawImage(patternImg, -drawW/2, -drawH/2, drawW, drawH);
  }
  pctx.restore();

  if(!displaceToggle.checked || !lumMap){
    const temp = document.createElement('canvas'); temp.width = pw; temp.height = ph;
    const tctx = temp.getContext('2d'); tctx.drawImage(pctx.canvas,0,0);
    if(eraseMask.width && eraseMask.height){ tctx.globalCompositeOperation='destination-in'; tctx.drawImage(eraseMask,0,0); tctx.globalCompositeOperation='source-over'; }
    if(maskCanvas){ tctx.globalCompositeOperation='destination-in'; tctx.drawImage(maskCanvas,0,0); tctx.globalCompositeOperation='source-over'; }
    ctx.globalAlpha = patternState.alpha; ctx.globalCompositeOperation = 'multiply';
    ctx.drawImage(temp,0,0);
    ctx.globalCompositeOperation = 'source-over'; ctx.globalAlpha = 1;
    return;
  }

  // displacement path (simplified)
  const pData = pctx.getImageData(0,0,pw,ph).data;
  const displaced = document.createElement('canvas'); displaced.width = pw; displaced.height = ph;
  const dctx = displaced.getContext('2d'); const out = dctx.createImageData(pw,ph); const outData = out.data;
  const strength = Number(displaceStrength.value);
  const gx = new Float32Array(pw*ph), gy = new Float32Array(pw*ph);
  for(let y=0;y<ph;y++) for(let x=0;x<pw;x++){ const i=y*pw+x; const left = x>0?lumMap[i-1]:lumMap[i]; const right = x<pw-1?lumMap[i+1]:lumMap[i]; const top = y>0?lumMap[i-pw]:lumMap[i]; const bottom = y<ph-1?lumMap[i+pw]:lumMap[i]; gx[i] = right-left; gy[i] = bottom-top; }
  for(let y=0;y<ph;y++) for(let x=0;x<pw;x++){ const i=y*pw+x; const dx = -gx[i] * (strength/50); const dy = -gy[i] * (strength/50); let sx = Math.round(x+dx), sy = Math.round(y+dy); if(sx<0) sx=0; if(sx>=pw) sx=pw-1; if(sy<0) sy=0; if(sy>=ph) sy=ph-1; const si=(sy*pw+sx)*4, oi=i*4; outData[oi]=pData[si]; outData[oi+1]=pData[si+1]; outData[oi+2]=pData[si+2]; outData[oi+3]=pData[si+3]; }
  dctx.putImageData(out,0,0);

  const temp2 = document.createElement('canvas'); temp2.width = pw; temp2.height = ph; const t2 = temp2.getContext('2d');
  t2.drawImage(displaced,0,0);
  if(eraseMask.width && eraseMask.height){ t2.globalCompositeOperation='destination-in'; t2.drawImage(eraseMask,0,0); t2.globalCompositeOperation='source-over'; }
  if(maskCanvas){ t2.globalCompositeOperation='destination-in'; t2.drawImage(maskCanvas,0,0); t2.globalCompositeOperation='source-over'; }
  ctx.globalAlpha = patternState.alpha; ctx.globalCompositeOperation = 'multiply';
  ctx.drawImage(temp2,0,0);
  ctx.globalCompositeOperation = 'source-over'; ctx.globalAlpha = 1;
}

/* simple checker background */
function drawCheckerBackground(context,w,h){ const size=16; for(let y=0;y<h;y+=size) for(let x=0;x<w;x+=size){ const even = ((x/size)+(y/size))%2===0; context.fillStyle = even ? '#f8f8f8' : '#efefef'; context.fillRect(x,y,size,size); } }

/* Sync UI */
function syncUI(){ posX.value = Math.round(patternState.x); posY.value = Math.round(patternState.y); scaleEl.value = patternState.scale; rotationEl.value = patternState.rot; opacityEl.value = patternState.alpha; }

/* Undo/Redo for erase mask */
function pushUndo(){ try{ const data = eraseMaskCtx.getImageData(0,0,eraseMask.width,eraseMask.height); undoStack.push(data); if(undoStack.length>UNDO_LIMIT) undoStack.shift(); redoStack.length = 0; updateUndoUI(); }catch(e){} }
function doUndo(){ if(undoStack.length===0) return; const img = undoStack.pop(); redoStack.push(eraseMaskCtx.getImageData(0,0,eraseMask.width,eraseMask.height)); eraseMaskCtx.putImageData(img,0,0); draw(); updateUndoUI(); }
function doRedo(){ if(redoStack.length===0) return; const img = redoStack.pop(); undoStack.push(eraseMaskCtx.getImageData(0,0,eraseMask.width,eraseMask.height)); eraseMaskCtx.putImageData(img,0,0); draw(); updateUndoUI(); }
function updateUndoUI(){ undoBtn.classList.toggle('disabled', undoStack.length===0); redoBtn.classList.toggle('disabled', redoStack.length===0); }
undoBtn.addEventListener('click', doUndo); redoBtn.addEventListener('click', doRedo);
resetEraseBtn.addEventListener('click', ()=>{ pushUndo(); eraseMaskCtx.clearRect(0,0,eraseMask.width,eraseMask.height); eraseMaskCtx.fillStyle='white'; eraseMaskCtx.fillRect(0,0,eraseMask.width,eraseMask.height); draw(); });

/* Pointer / brush / drag */
const activePointers = new Set();
let eraserMode = true, isErasing = false, dragging = false, dragOffset = {x:0,y:0}, lastPointerId = null;

function doBrushStroke(clientX,clientY){
  if(!eraseMaskCtx) return;
  if(activePointers.size > 1) return; // multi-touch -> ignore brushes (allow pinch)
  const rect = c.getBoundingClientRect(); const x = clientX - rect.left, y = clientY - rect.top;
  const size = Number(brushSizeEl.value), hardness = Number(brushHardEl.value);
  const b = document.createElement('canvas'); const bs = Math.max(8, Math.ceil(size)); b.width = bs; b.height = bs; const bctx = b.getContext('2d');
  const g = bctx.createRadialGradient(bs/2,bs/2,0,bs/2,bs/2,bs/2); g.addColorStop(0,'rgba(0,0,0,1)'); const stop = Math.max(0,Math.min(1,hardness)); g.addColorStop(stop,'rgba(0,0,0,1)'); g.addColorStop(1,'rgba(0,0,0,0)');
  bctx.clearRect(0,0,bs,bs); bctx.fillStyle = g; bctx.fillRect(0,0,bs,bs);
  eraseMaskCtx.save(); eraseMaskCtx.globalCompositeOperation='destination-out'; eraseMaskCtx.drawImage(b, x - bs/2, y - bs/2, bs, bs); eraseMaskCtx.globalCompositeOperation='source-over'; eraseMaskCtx.restore();
  draw();
}

c.addEventListener('pointerdown', e=>{
  activePointers.add(e.pointerId);
  if(activePointers.size > 1){ isErasing = false; dragging = false; lastPointerId = null; return; }
  const rect = c.getBoundingClientRect(); const x = e.clientX - rect.left, y = e.clientY - rect.top;

  // hit test for dragging motif if not in eraser mode
  if(!eraserMode && patternImg){
    const w = (patternImg.naturalWidth||patternImg.width) * Math.min((c.width*0.6)/(patternImg.naturalWidth||patternImg.width),(c.height*0.6)/(patternImg.naturalHeight||patternImg.height)) * patternState.scale;
    const h = (patternImg.naturalHeight||patternImg.height) * Math.min((c.width*0.6)/(patternImg.naturalWidth||patternImg.width),(c.height*0.6)/(patternImg.naturalHeight||patternImg.height)) * patternState.scale;
    const dx = x - patternState.x, dy = y - patternState.y; const theta = -patternState.rot * Math.PI/180;
    const rx = dx*Math.cos(theta) - dy*Math.sin(theta), ry = dx*Math.sin(theta) + dy*Math.cos(theta);
    if(Math.abs(rx) <= w/2 + 20 && Math.abs(ry) <= h/2 + 20){
      dragging = true; dragOffset.x = dx; dragOffset.y = dy; try{ c.setPointerCapture(e.pointerId); }catch(_){} lastPointerId = e.pointerId; return;
    }
  }

  // start erasing
  ensureEraseMaskSize(c.width,c.height);
  pushUndo();
  isErasing = true; lastPointerId = e.pointerId;
  try{ c.setPointerCapture(e.pointerId); }catch(_){} 
  doBrushStroke(e.clientX, e.clientY);
});

c.addEventListener('pointermove', e=>{
  if(!activePointers.has(e.pointerId)) activePointers.add(e.pointerId);
  if(activePointers.size > 1) return;
  if(dragging && !eraserMode){
    const rect = c.getBoundingClientRect(); const x = e.clientX - rect.left, y = e.clientY - rect.top;
    patternState.x = x - dragOffset.x; patternState.y = y - dragOffset.y; syncUI(); draw(); return;
  }
  if(!isErasing || lastPointerId !== e.pointerId) return;
  doBrushStroke(e.clientX, e.clientY);
});

c.addEventListener('pointerup', e=>{
  activePointers.delete(e.pointerId);
  if(lastPointerId === e.pointerId){ isErasing = false; dragging = false; try{ c.releasePointerCapture(e.pointerId); }catch(_){} lastPointerId = null; }
});
c.addEventListener('pointercancel', e=>{ activePointers.delete(e.pointerId); isErasing = false; dragging = false; lastPointerId = null; });

/* sliders -> update patternState */
[posX,posY,scaleEl,rotationEl,opacityEl,displaceStrength].forEach(el=>{
  el.addEventListener('input', ()=>{
    patternState.x = Number(posX.value);
    patternState.y = Number(posY.value);
    patternState.scale = Number(scaleEl.value);
    patternState.rot = Number(rotationEl.value);
    patternState.alpha = Number(opacityEl.value);
    draw();
  });
});

/* +/- style interactions could be added; keeping minimal */

/* Eraser mode toggle via clicking icons (single-click) */
eraseBtn.addEventListener('click', ()=>{ eraserMode = true; eraseBtn.classList.add('active'); transformBtn.classList.remove('active'); updateTuneMode(); });
transformBtn.addEventListener('click', ()=>{ eraserMode = false; transformBtn.classList.add('active'); eraseBtn.classList.remove('active'); updateTuneMode(); });

/* center/reset/download */
centerBtn.addEventListener('click', ()=>{ patternState.x = c.width/2; patternState.y = c.height/2; syncUI(); draw(); });
resetBtn.addEventListener('click', ()=>{ shirtImg = null; patternImg = null; maskCanvas = null; lumMap = null; patternState = { x: c.width/2, y: c.height/2, scale:1, rot:0, alpha:1, tiled:false }; eraseMaskCtx.clearRect(0,0,eraseMask.width,eraseMask.height); eraseMaskCtx.fillStyle='white'; eraseMaskCtx.fillRect(0,0,eraseMask.width,eraseMask.height); undoStack.length = 0; redoStack.length = 0; syncUI(); draw(); });
downloadBtn.addEventListener('click', ()=>{
  if(!shirtImg && !patternImg) return;
  const scaleFactor = 2;
  const tmp = document.createElement('canvas'); tmp.width = c.width * scaleFactor; tmp.height = c.height * scaleFactor;
  const tctx = tmp.getContext('2d');
  if(shirtImg) tctx.drawImage(shirtImg,0,0,tmp.width,tmp.height); else drawCheckerBackground(tctx,tmp.width,tmp.height);

  const pCanvas = document.createElement('canvas'); pCanvas.width = tmp.width; pCanvas.height = tmp.height; const pctx = pCanvas.getContext('2d');
  pctx.save(); pctx.translate(patternState.x*scaleFactor, patternState.y*scaleFactor); pctx.rotate(patternState.rot*Math.PI/180); pctx.scale(patternState.scale, patternState.scale);
  if(patternState.tiled){ const patt = pctx.createPattern(patternImg,'repeat'); pctx.fillStyle = patt; pctx.fillRect(-pCanvas.width,-pCanvas.height,pCanvas.width*2,pCanvas.height*2); }
  else { const w = patternImg.naturalWidth || patternImg.width; const h = patternImg.naturalHeight || patternImg.height; const defaultScale = Math.min((pCanvas.width*0.6)/w, (pCanvas.height*0.6)/h); const drawW=w*defaultScale; const drawH=h*defaultScale; pctx.drawImage(patternImg,-drawW/2,-drawH/2,drawW,drawH); }
  pctx.restore();

  const eScaled = document.createElement('canvas'); eScaled.width = tmp.width; eScaled.height = tmp.height; const ectx = eScaled.getContext('2d'); ectx.drawImage(eraseMask,0,0,tmp.width,tmp.height);
  const temp = document.createElement('canvas'); temp.width = tmp.width; temp.height = tmp.height; const tt = temp.getContext('2d'); tt.drawImage(pCanvas,0,0); tt.globalCompositeOperation='destination-in'; tt.drawImage(eScaled,0,0); tt.globalCompositeOperation='source-over';
  if(maskCanvas){ const mScaled = document.createElement('canvas'); mScaled.width = tmp.width; mScaled.height = tmp.height; const mctx = mScaled.getContext('2d'); mctx.drawImage(maskCanvas,0,0,tmp.width,tmp.height); tt.globalCompositeOperation='destination-in'; tt.drawImage(mScaled,0,0); tt.globalCompositeOperation='source-over'; }
  tctx.globalAlpha = patternState.alpha; tctx.globalCompositeOperation = 'multiply'; tctx.drawImage(temp,0,0); tctx.globalCompositeOperation = 'source-over'; tctx.globalAlpha = 1;

  const link = document.createElement('a'); link.download = 'mockup.png'; link.href = tmp.toDataURL('image/png'); link.click();
});

/* File input events */
shirtFile.addEventListener('change', e=>{
  const f = e.target.files[0]; if(!f) return;
  loadImageFromFile(f, img=>{
    shirtImg = img;
    fitCanvasToShirt();
    generateMaskFromShirt();
    computeLuminanceMap();
    ensureEraseMaskSize(c.width,c.height);
    syncUI(); draw();
  });
});

patternFile.addEventListener('change', e=>{
  const f = e.target.files[0]; if(!f) return;
  loadImageFromFile(f, img=>{
    patternImg = img;
    // default placement center & visible
    patternState = { x: c.width/2, y: c.height/2, scale: 1, rot: 0, alpha: 1, tiled: false };
    ensureEraseMaskSize(c.width,c.height);
    syncUI(); draw();
  });
});

/* Tuning slider logic (single control that maps to active panel) */
function updateTuneMode(){
  if(uploadPanel.style.display === 'block'){ tuneLabel.textContent = 'Upload'; tuneSlider.min=0; tuneSlider.max=1; tuneSlider.value=1; }
  else if(transformPanel.style.display === 'block'){ tuneLabel.textContent = 'Transform: Scale'; tuneSlider.min=0.1; tuneSlider.max=5; tuneSlider.step=0.01; tuneSlider.value = scaleEl.value || 1; }
  else if(eraserPanel.style.display === 'block'){ tuneLabel.textContent = 'Eraser Size'; tuneSlider.min=4; tuneSlider.max=200; tuneSlider.step=1; tuneSlider.value = brushSizeEl.value || 40; }
  else if(displacePanel.style.display === 'block'){ tuneLabel.textContent = 'Displace Strength'; tuneSlider.min=0; tuneSlider.max=120; tuneSlider.value = displaceStrength.value || 18; }
  else { tuneLabel.textContent = 'â€”'; tuneSlider.min=0; tuneSlider.max=100; tuneSlider.value=50; }
  tuneValue.textContent = tuneSlider.value;
}
tuneSlider.addEventListener('input', ()=>{
  tuneValue.textContent = tuneSlider.value;
  if(transformPanel.style.display === 'block'){ scaleEl.value = tuneSlider.value; scaleEl.dispatchEvent(new Event('input')); }
  if(eraserPanel.style.display === 'block'){ brushSizeEl.value = tuneSlider.value; }
  if(displacePanel.style.display === 'block'){ displaceStrength.value = tuneSlider.value; displaceStrength.dispatchEvent(new Event('input')); }
});

/* keep tune panel updated when panels open/close */
[uploadBtn,transformBtn,eraseBtn,displaceBtn].forEach(b => b.addEventListener('click', ()=> setTimeout(updateTuneMode,120)));
[scaleEl, brushSizeEl, displaceStrength].forEach(el => el.addEventListener('input', updateTuneMode));

/* init */
function init(){
  // ensure initial CSS sizing matches canvas pixel size
  c.style.width = c.width + "px";
  c.style.height = c.height + "px";
  c.style.transform = "translate(-50%,-50%)";
  ensureEraseMaskSize(c.width,c.height);
  syncUI();
  draw();
}
init();
</script>
</body>
</html>